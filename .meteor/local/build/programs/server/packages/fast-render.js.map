{"version":3,"file":"/packages/fast-render.js","sources":["fast-render/lib/server/utils.js","fast-render/lib/server/fast_render.js","fast-render/lib/server/context.js","fast-render/lib/server/inject.js","fast-render/lib/server/iron_router_support.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,2C;AACA,kD;AACA,E;;AAEA,W;;AAEA,yE;AACA,4D;AACA,6D;AACA,a;AACA,+B;AACA,6B;AACA,mH;AACA,sD;AACA,0B;AACA,e;AACA,iC;AACA,e;AACA,iC;AACA,mF;AACA,0B;AACA,gC;AACA,M;AACA,gC;AACA,4B;AACA,4D;AACA,E;;AAEA,oD;AACA,uB;AACA,iB;AACA,kC;;AAEA,uB;;AAEA,iD;AACA,0B;;AAEA,S;AACA,uC;AACA,kC;AACA,e;AACA,gB;AACA,mE;AACA,uB;AACA,gB;AACA,K;;AAEA,c;AACA,6B;AACA,Y;AACA,uB;AACA,K;AACA,G;;AAEA,gB;AACA,E;;;;;;;;;;;;;;;;;;ACzDA,kC;;AAEA,c;AACA,c;AACA,kB;AACA,E;;AAEA,mD;AACA,gB;AACA,2B;AACA,wD;AACA,uB;AACA,c;AACA,K;AACA,E;;AAEA,yD;AACA,yC;AACA,E;;AAEA,iF;AACA,oB;AACA,a;;AAEA,qD;AACA,uC;AACA,2C;AACA,gB;AACA,4B;AACA,Y;AACA,K;AACA,G;;AAEA,oB;AACA,0C;AACA,S;AACA,6C;AACA,0D;AACA,qC;AACA,S;;AAEA,yB;AACA,2D;AACA,O;;AAEA,kC;AACA,kB;AACA,wF;AACA,qB;AACA,K;AACA,W;AACA,E;;;;;;;;;;;;;;;;;;ACnDA,mC;AACA,0C;;AAEA,wC;AACA,4B;AACA,2B;;AAEA,gB;AACA,oB;AACA,2B;AACA,0D;AACA,yE;AACA,yE;AACA,K;AACA,Q;AACA,gE;AACA,qC;AACA,oD;;AAEA,6B;AACA,yC;AACA,wE;;AAEA,c;AACA,6B;AACA,K;AACA,G;AACA,E;;AAEA,mE;AACA,kB;AACA,uD;AACA,0C;AACA,gD;AACA,yF;AACA,G;;AAEA,mE;AACA,yB;AACA,8B;AACA,wD;AACA,mD;;AAEA,+D;AACA,e;AACA,kB;AACA,c;AACA,+C;AACA,0D;AACA,wB;AACA,O;AACA,O;AACA,kB;AACA,U;AACA,yE;AACA,G;AACA,E;;AAEA,oE;AACA,kB;AACA,4E;AACA,sB;AACA,0D;AACA,qD;AACA,iB;AACA,wC;AACA,4B;AACA,O;;AAEA,2B;AACA,wC;AACA,wB;AACA,6B;AACA,iH;AACA,uF;;AAEA,+C;AACA,kE;AACA,S;;AAEA,wB;AACA,+C;AACA,Y;AACA,qE;AACA,K;AACA,U;AACA,0E;AACA,G;AACA,E;;AAEA,mE;AACA,kB;AACA,wC;AACA,oC;AACA,mE;AACA,0F;AACA,G;;AAEA,gD;AACA,6C;AACA,K;AACA,E;;AAEA,gE;AACA,6C;AACA,8C;AACA,G;AACA,E;;AAEA,wC;AACA,U;AACA,yC;AACA,sC;AACA,I;AACA,E;;AAEA,8B;;;;;;;;;;;;;;;;;;;ACpHA,yE;AACA,0B;AACA,mC;AACA,uC;;AAEA,+B;;AAEA,uB;AACA,mE;AACA,W;AACA,+E;AACA,U;AACA,iD;AACA,G;AACA,G;;AAEA,yB;AACA,qE;AACA,W;AACA,iF;AACA,U;AACA,mD;AACA,G;AACA,G;;AAEA,yD;AACA,kE;AACA,yC;AACA,yC;AACA,8D;;AAEA,2E;AACA,mE;AACA,qC;AACA,sD;AACA,wB;AACA,4F;AACA,gC;AACA,gD;AACA,a;AACA,K;;AAEA,mB;AACA,8B;AACA,wC;AACA,oD;AACA,wD;AACA,qE;AACA,iG;AACA,S;AACA,wE;AACA,sE;AACA,Y;AACA,6D;AACA,K;;AAEA,iB;AACA,4B;AACA,yC;AACA,qD;AACA,S;AACA,sE;AACA,iE;AACA,Y;AACA,2D;AACA,K;;AAEA,yB;AACA,G;;AAEA,4C;AACA,E;;AAEA,2E;AACA,4C;AACA,sB;AACA,sD;AACA,iB;;AAEA,kE;AACA,kE;AACA,oE;AACA,oE;AACA,8D;AACA,kD;AACA,8B;AACA,iB;;AAEA,iE;AACA,sE;AACA,iB;;AAEA,wD;AACA,c;AACA,E;;AAEA,4B;AACA,kE;AACA,qD;AACA,uB;AACA,uD;AACA,wE;AACA,gC;AACA,yB;AACA,gD;AACA,O;AACA,a;AACA,O;AACA,qD;AACA,U;AACA,W;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AChHA,mC;;AAEA,6D;AACA,uD;;AAEA,8B;AACA,2C;AACA,uC;AACA,E;;AAEA,2C;AACA,2B;AACA,yC;AACA,8B;AACA,sE;AACA,gE;AACA,K;AACA,2C;AACA,K;;AAEA,6D;AACA,yC;AACA,2C;AACA,sB;AACA,M;AACA,gC;AACA,sC;AACA,mD;AACA,yC;AACA,S;AACA,O;AACA,G;AACA,G;;AAEA,qC;AACA,qB;AACA,gB;AACA,iB;AACA,wE;AACA,mB;AACA,oC;AACA,yC;AACA,gB;AACA,kC;AACA,mC;AACA,8C;AACA,+D;AACA,I;AACA,yD;AACA,yC;AACA,gB;AACA,U;AACA,iB;AACA,G;;AAEA,+B;AACA,kC;AACA,oB;AACA,mB;AACA,qB;AACA,gB;AACA,M;;AAEA,0B;AACA,8B;AACA,iC;;AAEA,iD;AACA,uC;AACA,O;AACA,G;;AAEA,sB;AACA,wC;AACA,G;AACA,C;;AAEA,qD;AACA,mB;AACA,+C;AACA,iB;AACA,G","sourcesContent":["/*\n  stolen from express: http://goo.gl/qgarJu\n  some parts has been changed to deal with our api\n*/\n\nUtils = {};\n\nUtils._pathRegexp = function _pathRegexp(path, keys, sensitive, strict) {\n  if (toString.call(path) == '[object RegExp]') return path;\n  if (Array.isArray(path)) path = '(' + path.join('|') + ')';\n  path = path\n    .concat(strict ? '' : '/?')\n    .replace(/\\/\\(/g, '(?:/')\n    .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?(\\*)?/g, function(_, slash, format, key, capture, optional, star){\n      keys.push({ name: key, optional: !! optional });\n      slash = slash || '';\n      return ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + (optional ? slash : '')\n        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n        + (optional || '')\n        + (star ? '(/*)?' : '');\n    })\n    .replace(/([\\/.])/g, '\\\\$1')\n    .replace(/\\*/g, '(.*)');\n  return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n};\n\nUtils._pathMatch = function _pathMatch(path, route){\n  var keys = route.keys\n    , params = []\n    , m = route.regexp.exec(path);\n\n  if (!m) return false;\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n\n    try {\n      var val = 'string' == typeof m[i]\n        ? decodeURIComponent(m[i])\n        : m[i];\n    } catch(e) {\n      var err = new Error(\"Failed to decode param '\" + m[i] + \"'\");\n      err.status = 400;\n      throw err;\n    }\n\n    if (key) {\n      params[key.name] = val;\n    } else {\n      params.push(val);\n    }\n  }\n\n  return params;\n};","var Fiber = Npm.require('fibers');\n\nFastRender = {\n  _routes: [],\n  _onAllRoutes: []\n};\n\nFastRender.route = function route(path, callback) {\n  var keys = [];\n  FastRender._routes.push({\n    regexp: Utils._pathRegexp(path, keys, false, false),\n    callback: callback,\n    keys: keys\n  });\n};\n\nFastRender.onAllRoutes = function onAllRoutes(callback) {\n  FastRender._onAllRoutes.push(callback);\n};\n\nFastRender._processRoutes = function _processRoutes(path, loginToken, callback) {\n  var selectedRoute;\n  var params;\n\n  for(var lc=0; lc<FastRender._routes.length; lc++) {\n    var route = FastRender._routes[lc];\n    params = Utils._pathMatch(path, route);\n    if(params) {\n      selectedRoute = route;\n      break;\n    }\n  }\n\n  Fiber(function() {\n    var context = new Context(loginToken);\n    try {\n      //run onAllRoutes callbacks if provided\n      FastRender._onAllRoutes.forEach(function(callback) {\n        callback.call(context, path);\n      });\n\n      if(selectedRoute) {\n        selectedRoute.callback.call(context, params, path);\n      }\n\n      callback(context.getData());\n    } catch(err) {\n      console.error('error on fast-rendering path: ' + path + \" ; error: \" + err.stack);\n      callback(null);\n    }\n  }).run();\n};","var Fibers = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nContext = function Context(loginToken) {\n  this._collectionData = {};\n  this._subscriptions = {};\n\n  //get the user\n  if(Meteor.users) {\n    var hashedToken, query;\n    if ( typeof Accounts._hashLoginToken === 'function' ){\n      hashedToken = loginToken && Accounts._hashLoginToken( loginToken );\n      query = {'services.resume.loginTokens.hashedToken': hashedToken }; \n    }\n    else\n      query = {'services.resume.loginTokens.token': loginToken};\n    var options = {fields: {_id: 1}};\n    var user = Meteor.users.findOne(query, options);\n\n    //support for Meteor.user\n    Fibers.current._meteor_dynamics = {};\n    Fibers.current._meteor_dynamics[DDP._CurrentInvocation.slot] = this;\n\n    if(user) {\n      this.userId = user._id;\n    }\n  }\n};\n\nContext.prototype.find = function(collectionName, query, options) {\n  var self = this;\n  if(collectionName.constructor == Meteor.Collection) {\n    collectionName = collectionName._name;\n  } else if(typeof collectionName != 'string') {\n    throw new Error(\"find's first arg should be either a Meteor.Collection or a string\");\n  }\n\n  var mongo = MongoInternals.defaultRemoteCollectionDriver().mongo;\n  if(mongo && mongo.db) {\n    var future = new Future();\n    var args = Array.prototype.slice.call(arguments, 1);\n    var coll = mongo.db.collection(collectionName);\n\n    coll.find.apply(coll, args).toArray(function(err, result) {\n      if(err) {\n        throw err;\n      } else {\n        self._ensureCollection(collectionName);\n        self._collectionData[collectionName].push(result);\n        future.return();\n      }\n    });\n    future.wait();\n  } else {\n    console.warn('fast-render still cannot access the mongo connection');\n  }\n};\n\nContext.prototype.subscribe = function(subscription /*, params */) {\n  var self = this;\n  var publishHandler = Meteor.default_server.publish_handlers[subscription];\n  if(publishHandler) {\n    var params = Array.prototype.slice.call(arguments, 1);\n    var cursors = publishHandler.apply(this, params);\n    if(cursors) {\n      if(cursors.constructor != Array) {\n        cursors = [cursors];\n      }\n\n      //add collection data\n      cursors.forEach(function(cursor) {\n        cursor.rewind();\n        var collectionName = \n          (cursor._cursorDescription)? cursor._cursorDescription.collectionName: null || //for meteor-collections\n          (cursor._collection)? cursor._collection._name: null; //for smart-collections\n\n        self._ensureCollection(collectionName);\n        self._collectionData[collectionName].push(cursor.fetch());\n      });\n\n      //set subscription\n      self.completeSubscriptions(subscription);\n    } else {\n      console.warn('No such cursors in publication: ', subscription);\n    }\n  } else {\n    console.warn('There is no such publish handler named:', subscription);\n  }\n};\n\nContext.prototype.completeSubscriptions = function(subscriptions) {\n  var self = this;\n  if(typeof subscriptions == 'string') {\n    subscriptions = [subscriptions];\n  } else if(!subscriptions || subscriptions.constructor != Array) {\n    throw new Error('subscriptions params should be either a string or array of strings');\n  }\n\n  subscriptions.forEach(function(subscription) {\n    self._subscriptions[subscription] = true;\n  });\n};\n\nContext.prototype._ensureCollection = function(collectionName) {\n  if(!this._collectionData[collectionName]) {\n    this._collectionData[collectionName] = [];\n  }\n};\n\nContext.prototype.getData = function() {\n  return {\n    collectionData: this._collectionData,\n    subscriptions: this._subscriptions\n  };\n};\n\nFastRender._Context = Context;\n","//When a HTTP Request comes, we need to figure out is it a proper request\n//then get some query data\n//then hijack html return by meteor\n//code below, does that in abstract way\n\nvar http = Npm.require('http');\n\nvar injectDataTemplate;\nAssets.getText('lib/server/inject_data.html', function(err, text) {\n  if(err) {\n    console.error('Error reading fast-render inject_data.html: ', err.message);\n  } else {\n    injectDataTemplate = _.template(text.trim());\n  }\n});\n\nvar injectConfigTemplate;\nAssets.getText('lib/server/inject_config.html', function(err, text) {\n  if(err) {\n    console.error('Error reading fast-render inject_config.html: ', err.message);\n  } else {\n    injectConfigTemplate = _.template(text.trim());\n  }\n});\n\nvar originalWrite = http.OutgoingMessage.prototype.write;\nhttp.OutgoingMessage.prototype.write = function(chunk, encoding) {\n  //prevent hijacking other http requests\n  if(this.queryData && !this.injected && \n    encoding === undefined && /<!DOCTYPE html>/.test(chunk)) {\n\n    //if cors headers included if may cause some security holes. see more: \n    //so we simply turn off fast-render if we detect an cors header\n    //read more: http://goo.gl/eGwb4e\n    if(this._headers['access-control-allow-origin']) {\n      var wanrMessage = \n        'warn: fast-render turned off due to CORS headers. read more: http://goo.gl/eGwb4e';\n      console.warn(wanrMessage);\n      originalWrite.call(this, chunk, encoding);\n      return;\n    }\n\n    //inject config\n    if(injectConfigTemplate) {\n      var jsonContent = JSON.stringify({\n        subscriptions: this.queryData.subscriptions,\n        serverRoutePath: this.queryData.serverRoutePath,\n        subscriptionIdMap: {}, //map of ids and its subscription name\n        loadedSubscriptions: {} //loaded Subscriptions, which have been forcely completed earlier\n      });\n      var injectHtml = injectConfigTemplate({jsonContent: jsonContent});\n      chunk = chunk.replace('<head>', '<head>\\n' + injectHtml + '\\n');\n    } else {\n      console.warn('injectConfigTemplate is not ready yet!');\n    }\n\n    //inject data\n    if(injectDataTemplate) {\n      var ejsonString = EJSON.stringify({\n        collectionData: this.queryData.collectionData\n      });\n      var injectHtml = injectDataTemplate({ejsonString: ejsonString});\n      chunk = chunk.replace('</head>', injectHtml + '\\n</head>');\n    } else {\n      console.warn('injectDataTemplate is not ready yet!');\n    }\n\n    this.injected = true;\n  }\n\n  originalWrite.call(this, chunk, encoding);\n};\n\n//meteor algorithm to check if this is a meteor serving http request or not\n//add routepolicy package to the fast-render\nfunction appUrl(url) {\n  if (url === '/favicon.ico' || url === '/robots.txt')\n    return false;\n\n  // NOTE: app.manifest is not a web standard like favicon.ico and\n  // robots.txt. It is a file name we have chosen to use for HTML5\n  // appcache URLs. It is included here to prevent using an appcache\n  // then removing it from poisoning an app permanently. Eventually,\n  // once we have server side routing, this won't be needed as\n  // unknown URLs with return a 404 automatically.\n  if (url === '/app.manifest')\n    return false;\n\n  // Avoid serving app HTML for declared routes such as /sockjs/.\n  if (typeof(RoutePolicy) != 'undefined' && RoutePolicy.classify(url))\n    return false;\n\n  // we currently return app HTML on all URLs by default\n  return true;\n};\n\n//check page and add queries\nWebApp.connectHandlers.use(Npm.require('connect').cookieParser());\nWebApp.connectHandlers.use(function(req, res, next) {\n  if(appUrl(req.url)) {\n    var loginToken = req.cookies['meteor_login_token'];\n    FastRender._processRoutes(req.url, loginToken, function(queryData) {\n      res.queryData = queryData;\n      if(res.queryData) {\n        res.queryData.serverRoutePath = req.url;\n      }\n      next();\n    });\n    //run our route handlers and add proper queryData\n  } else {\n    next();\n  }\n});\n","if(!Package['iron-router']) return;\n\nvar RouteController = Package['iron-router'].RouteController;\nvar ServerRouter = Package['iron-router'].ServerRouter;\n\nvar currentSubscriptions = [];\nMeteor.subscribe = function(subscription) {\n  currentSubscriptions.push(arguments);\n};\n\n//assuming, no runtime routes will be added\nMeteor.startup(function() {\n  Router.routes.forEach(function(route) {\n    //resolve controller class\n    if(route.options && typeof route.options.controller == 'string') {\n      route.options.controller = this[route.options.controller];\n    }\n    handleRoute(route.name, route.options);\n  });\n\n  var globalWaitOn = Router.options && Router.options.waitOn;\n  if(typeof globalWaitOn == 'function') {\n    FastRender.onAllRoutes(function(path) {\n      var self = this;\n      \n      currentSubscriptions = [];\n      globalWaitOn.call({path: path});\n      currentSubscriptions.forEach(function(args) {\n        self.subscribe.apply(self, args);\n      });\n    });\n  }\n});\n\nfunction handleRoute(name, options) {\n  var waitOnFunction;\n  if(!options) {\n    return false;\n  } else if(options.fastRender && typeof options.waitOn == 'function') {\n    //do FR support\n    waitOnFunction = options.waitOn;\n    FastRender.route(getPath(), onRoute);\n    return true;\n  } else if(options.controller && \n    options.controller.prototype &&\n    options.controller.prototype.fastRender &&\n    typeof options.controller.prototype.waitOn == 'function') {\n    \n    waitOnFunction = options.controller.prototype.waitOn;\n    FastRender.route(getPath(), onRoute);\n    return true;\n  } else {\n    return false;\n  }\n\n  //FastRender onRoute callback\n  function onRoute(params, path) {\n    var self = this;\n    var context = {\n      params: params,\n      path: path\n    };\n\n    //reset subscriptions;\n    currentSubscriptions = [];\n    waitOnFunction.call(context);\n\n    currentSubscriptions.forEach(function(args) {\n      self.subscribe.apply(self, args);\n    });\n  }\n\n  function getPath() {\n    return options.path || (\"/\" + name);\n  }\n}\n\nFastRender.RouteController = RouteController.extend({\n  fastRender: true,\n  //disabling any IR specific serverside stuffs\n  where: 'client'\n});"]}