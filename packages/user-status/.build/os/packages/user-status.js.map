{"version":3,"file":"/packages/user-status.js","sources":["user-status/user_status.js"],"names":[],"mappings":";;;;;;;;AAAA,E;AACA,kG;AACA,8F;;AAEA,oF;AACA,kE;AACA,E;;AAEA,4C;;AAEA,2C;;AAEA,wD;;AAEA,6C;AACA,iC;AACA,oC;AACA,mB;AACA,wB;AACA,K;;;AAGA,iD;AACA,kB;AACA,uC;AACA,mD;AACA,4C;AACA,yD;AACA,6C;AACA,2C;AACA,wE;AACA,W;AACA,e;AACA,6E;AACA,W;AACA,U;AACA,W;AACA,qD;AACA,K;;AAEA,G;AACA,E;;AAEA,yB;AACA,kB;AACA,qB;AACA,iC;AACA,a;AACA,8B;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,2B;AACA,kC;AACA,a;AACA,2B;AACA,K;AACA,M;AACA,e;AACA,K;AACA,G;;AAEA,iC;AACA,2D;AACA,gC;AACA,qC;AACA,W;AACA,G;AACA,+B;AACA,0B;AACA,uB;AACA,+C;AACA,2B;AACA,a;AACA,K;AACA,8C;AACA,W;AACA,G;AACA,oI;AACA,E;AACA,sD;AACA,kB;AACA,uC;AACA,mD;AACA,4C;AACA,yD;AACA,6C;AACA,2C;AACA,wE;AACA,W;AACA,e;AACA,4E;AACA,W;;AAEA,W;AACA,8C;AACA,K;AACA,G;AACA,E;AACA,kC;AACA,W;AACA,qB;AACA,qB;AACA,0B;AACA,K;AACA,K;AACA,mC;AACA,mB;AACA,yB;AACA,mB;AACA,wB;AACA,K;AACA,+B;AACA,W;AACA,4B;AACA,mC;AACA,K;AACA,K;AACA,sE;AACA,4C;AACA,kB;AACA,yE;AACA,M;AACA,G","sourcesContent":["/*\n  Apparently, the new api.export takes care of issues here. No need to attach to global namespace.\n  See http://shiggyenterprises.wordpress.com/2013/09/09/meteor-packages-in-coffeescript-0-6-5/\n\n  We may want to make UserSessions a server collection to take advantage of indices.\n  Will implement if someone has enough online users to warrant it.\n*/\n\nvar UserSessions, UserStatus, removeSession;\n\nUserSessions = new Meteor.Collection(null);\n\nUserStatus = new (Npm.require('events').EventEmitter)();\n\nremoveSession = function(userId, sessionId) {\n  UserSessions.remove(sessionId);\n  UserStatus.emit(\"sessionLogout\", {\n    userId: userId,\n    sessionId: sessionId\n  });\n\n\n  var cursorUsers = Meteor.users.findOne(userId);\n  if(cursorUsers){\n    if(cursorUsers.services.instagram){\n        var id = cursorUsers.services.instagram.id;\n        var name = cursorUsers.profile.name;\n        var cursorFollows = Follows.find({\"followid\":id})\n        cursorFollows.forEach(function(data){\n          if(data.followid == data.userid){\n            Follows.update({\"_id\":data._id},{$set : {\"status\":\"none\"}});\n          }\n          else{\n            Follows.update({\"_id\":data._id},{$set : {\"status\":\"offline\"}});  \n          }\n          \n        });\n        console.log(\"offline \" +id +\" \" +name);      \n    }\n\n  }\n  \n\n  if (UserSessions.find({\n    userId: userId\n  }).count() === 0) {\n    Meteor.users.update(userId, {\n      $set: {\n        'status.online': false\n      }\n    });\n  }\n};\n\nMeteor.startup(function() {\n  return Meteor.users.update({}, {\n    $unset: {\n      \"status.online\": null\n    }\n  }, {\n    multi: true\n  });\n});\n\nMeteor.publish(null, function() {\n  var existing, ipAddr, sessionId, timestamp, userId, _ref;\n  userId = this._session.userId;\n  if (this._session.socket == null) {\n    return;\n  }\n  sessionId = this._session.id;\n  timestamp = +(new Date);\n  if (userId == null) {\n    existing = UserSessions.findOne(sessionId);\n    if (existing == null) {\n      return;\n    }\n    removeSession(existing.userId, sessionId);\n    return;\n  }\n  ipAddr = ((_ref = this._session.socket.headers) != null ? _ref['x-forwarded-for'] : void 0) || this._session.socket.remoteAddress;\n  \n  var cursorUsers = Meteor.users.findOne(this.userId);\n  if(cursorUsers){\n    if(cursorUsers.services.instagram){\n        var id = cursorUsers.services.instagram.id;\n        var name = cursorUsers.profile.name;\n        var cursorFollows = Follows.find({\"followid\":id})\n        cursorFollows.forEach(function(data){\n          if(data.followid == data.userid){\n            Follows.update({\"_id\":data._id},{$set : {\"status\":\"none\"}});\n          }\n          else{\n            Follows.update({\"_id\":data._id},{$set : {\"status\":\"online\"}});  \n          }\n\n        });\n        console.log(\"online \" +id +\" \" +name);\n    }\n  }\n  \n  UserSessions.insert(sessionId, {\n    $set: {\n      userId: userId,\n      ipAddr: ipAddr,\n      loginTime: timestamp\n    }\n  });\n  UserStatus.emit(\"sessionLogin\", {\n    userId: userId,\n    sessionId: sessionId,\n    ipAddr: ipAddr,\n    loginTime: timestamp\n  });\n  Meteor.users.update(userId, {\n    $set: {\n      'status.online': true,\n      'status.lastLogin': timestamp\n    }\n  });\n  this._session.socket.on(\"close\", Meteor.bindEnvironment(function() {\n    return removeSession(userId, sessionId);\n  }, function(e) {\n    return Meteor._debug(\"Exception from connection close callback:\", e);\n  }));\n});\n"]}