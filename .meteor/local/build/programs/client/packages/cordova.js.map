)]}'
{"version":3,"file":"/packages/cordova.js","sources":["cordova/cordova.client.js","cordova/cordova.client.notification.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,iB;;AAEA,E;;AAEA,6B;AACA,kB;;AAEA,sF;;AAEA,kB;AACA,gB;AACA,I;;AAEA,+D;AACA,uC;AACA,mD;;AAEA,sC;AACA,0C;AACA,kC;AACA,O;AACA,K;;AAEA,G;;AAEA,uB;;AAEA,kC;;AAEA,oD;AACA,yB;;AAEA,8D;AACA,oB;AACA,yB;;AAEA,wD;AACA,2B;;AAEA,oB;AACA,wB;AACA,uB;AACA,I;;AAEA,2B;AACA,sB;AACA,0C;;AAEA,6B;AACA,6B;AACA,uB;AACA,I;;AAEA,mC;AACA,gC;AACA,0B;AACA,gC;AACA,K;AACA,I;;AAEA,uD;AACA,yC;AACA,sF;AACA,K;AACA,8D;;AAEA,mB;AACA,wC;;AAEA,6D;AACA,iB;AACA,wB;AACA,S;AACA,K;AACA,6B;AACA,uD;AACA,I;;AAEA,2D;AACA,wD;AACA,kC;AACA,K;AACA,qD;AACA,I;;AAEA,wE;AACA,gF;AACA,2C;AACA,iD;AACA,yE;AACA,kD;AACA,sB;AACA,gB;AACA,K;;AAEA,qD;;AAEA,yC;AACA,sE;AACA,K;;AAEA,wC;AACA,oB;;;AAGA,sC;AACA,4C;;AAEA,4C;AACA,iD;;AAEA,+D;AACA,2C;AACA,wB;AACA,sC;AACA,sC;AACA,6D;AACA,wC;AACA,c;AACA,oC;AACA,O;AACA,yB;AACA,mB;AACA,e;AACA,yB;AACA,uB;AACA,kB;AACA,O;AACA,I;;AAEA,iC;AACA,gC;AACA,yD;AACA,sC;AACA,U;AACA,gC;AACA,oB;AACA,oE;AACA,kE;AACA,O;AACA,kC;AACA,mD;AACA,Y;AACA,oE;AACA,sC;AACA,K;AACA,I;;AAEA,mC;AACA,+C;AACA,4C;AACA,qC;AACA,wC;AACA,8C;AACA,0B;AACA,qD;AACA,4D;AACA,0C;AACA,S;AACA,O;AACA,0B;AACA,6B;AACA,K;;AAEA,kC;AACA,6C;AACA,uD;AACA,6C;AACA,+C;AACA,oD;AACA,e;AACA,sD;AACA,wB;AACA,W;AACA,S;AACA,4E;AACA,8C;AACA,kD;AACA,S;AACA,O;AACA,qB;;AAEA,yC;AACA,8C;AACA,gD;AACA,8C;;AAEA,8B;AACA,+C;AACA,2C;AACA,e;AACA,O;;AAEA,iC;AACA,gD;AACA,mD;AACA,e;AACA,O;;AAEA,+B;AACA,gC;AACA,gE;AACA,kE;AACA,yB;AACA,4B;AACA,wC;AACA,U;AACA,+B;AACA,+B;AACA,S;AACA,Q;;AAEA,kD;AACA,mH;AACA,e;AACA,O;;AAEA,gE;AACA,oB;AACA,iC;AACA,iC;AACA,O;;AAEA,0C;AACA,W;AACA,iD;AACA,oB;AACA,kH;AACA,O;;AAEA,oD;AACA,4B;AACA,6D;;AAEA,iE;AACA,yE;AACA,uE;AACA,4C;AACA,gB;AACA,6E;AACA,sD;AACA,wD;AACA,S;AACA,O;AACA,kB;;AAEA,oB;AACA,4D;AACA,K;AACA,qB;;AAEA,8C;AACA,qC;AACA,oC;AACA,6B;AACA,2C;AACA,K;AACA,I;;AAEA,iC;AACA,uD;AACA,wE;AACA,G;;AAEA,iC;AACA,mD;AACA,yB;AACA,wB;AACA,uC;AACA,mC;AACA,6C;AACA,iC;AACA,O;AACA,K;AACA,K;;AAEA,c;AACA,E;;;;;;;;;;;;;;;;;;;ACtRA,E;;AAEA,uB;;AAEA,6C;;AAEA,W;;AAEA,0D;;AAEA,E;;AAEA,E;AACA,yB;AACA,gC;AACA,2B;AACA,G;;AAEA,qC;AACA,6B;AACA,C;;AAEA,yB;AACA,M;AACA,yB;AACA,uE;AACA,+B;AACA,a;AACA,6C;AACA,kC;AACA,I;AACA,E;;AAEA,gD;AACA,6C;;AAEA,gB;AACA,kB;AACA,oB;AACA,oB;AACA,mC;;AAEA,yC;AACA,sB;AACA,sC;AACA,yB;AACA,qC;AACA,+C;AACA,mB;AACA,W;AACA,qB;AACA,M;AACA,K;;AAEA,sD;;AAEA,+E;AACA,iB;AACA,mC;AACA,yC;AACA,kE;;AAEA,yD;AACA,yF;AACA,U;AACA,wB;AACA,wB;AACA,kB;AACA,E;AACA,E;;AAEA,qF;AACA,iB;AACA,2C;AACA,oE;;AAEA,yD;AACA,+F;AACA,U;AACA,oD;AACA,G;AACA,E;;AAEA,gG;AACA,iB;AACA,2C;AACA,qE;;AAEA,0D;AACA,0G;AACA,U;AACA,qD;AACA,kB;AACA,qB;AACA,4D;AACA,O;AACA,G;;AAEA,E;;AAEA,0C;AACA,iB;AACA,qB;AACA,yD;AACA,oD;AACA,U;AACA,uC;AACA,4B;AACA,sB;AACA,8B;AACA,M;AACA,I;AACA,mB;AACA,E;AACA,E;;AAEA,oD;AACA,iB;AACA,2D;AACA,8D;AACA,U;AACA,wB;AACA,G;AACA,E;;AAEA,sC;AACA,kB;AACA,qC;AACA,E","sourcesContent":["/*\nCode by RaiX 2013\n\n*/\n\nCordova = function(options) {\n  var self = this;\n\n  self.debug = (options && typeof options.debug !== 'undefined')?options.debug: false;\n\n  self.plugins = {\n    loaded: true\n  };\n\n  // Add plugins and set them deactivated until device is ready\n  if (typeof options !== 'undefined' &&\n          typeof options.plugins !== 'undefined') {\n\n    for (var key in options.plugins) {\n      if (options.plugins[key] === true) {\n        self.plugins[key] = false;\n      }\n    }\n\n  }\n\n  self.url = 'file://';\n\n  self.handshakeActivated = false;\n\n  // If no handshake we put messages into FIFO queue\n  self.messageQueue = [];\n\n  // array of invokeId of callbacks 0 = the returning callback\n  self.invokes = {};\n  self.invokeCounter = 0;\n\n  // array of eventId's containing an array of listeners\n  self.eventCallbacks = {};\n\n  // one time events\n  self.oneTimeEvents = {\n    'deviceready': true\n  };\n\n  // Rig reactive ready var\n  self._ready = false;\n  self._readyDeps = new Deps.Dependency();\n\n  self.isReady = function() {\n    self._readyDeps.depend();\n    return self._ready;\n  };\n\n  self.setReady = function(value) {\n    if (value !== self._ready) {\n      self._ready = value;\n      self._readyDeps.changed();\n    }\n  };\n\n  self.addEventListener = function(eventId, callback) {\n    if (typeof callback !== 'function') {\n      throw new Error('ERROR: Cordova.addEventListener expects callback as function');\n    }\n    if (typeof self.eventCallbacks[eventId] === 'undefined') {\n\n      // Initialize\n      self.eventCallbacks[eventId] = [];\n\n      // Let the cordova know we are interested in this event\n      self.send({\n        eventId: eventId\n      });\n    }\n    // Return the callback id\n    return self.eventCallbacks[eventId].push(callback);\n  };\n\n  self.addInvokingCallback = function(invokeId, callback) {\n    if (typeof self.invokes[invokeId] === 'undefined') {\n      self.invokes[invokeId] = [];\n    }\n    return self.invokes[invokeId].push(callback) - 1;\n  };\n\n  // command 'window.test' args [a, v], callback returns resulting value\n  // args and callback are both optional if no callback and args a function then\n  // no args are assumed and callback isset\n  self.call = function(command, args, callback) {\n    // Support that the user skips the arguments and only sets a callback\n    if (!callback && typeof args === 'function') {\n      callback = args;\n      args = [];\n    }\n\n    callback = (callback) ? callback : function() {};\n\n    if (typeof callback !== 'function') {\n      throw new Error('MeteorCordova expects callback as a function');\n    }\n\n    var invokeId = self.invokeCounter++;\n    var myArgs = [];\n\n\n    // args should allways be an array\n    args = (args && args.length)? args : [];\n\n    // We set the returning callback id == 0\n    self.addInvokingCallback(invokeId, callback);\n\n    // We parse the arguments and filter out callback functions\n    for (var i = 0; i < args.length; i++) {\n      var arg = args[i];\n      // If the argument is a function\n      if (typeof arg === 'function') {\n        var funcId = self.addInvokingCallback(invokeId, arg);\n        myArgs.push({ funcId: funcId });\n      } else {\n        myArgs.push({ value: arg });\n      }\n    } // EO arg preparing\n    // Send message\n    self.send({\n      invokeId: invokeId,\n      command: command,\n      args: myArgs\n    });\n  };\n\n  self.send = function(message) {\n    // Check if we are in iframe\n    if (typeof window !== 'undefined' && window.parent &&\n            self.handshakeActivated) {\n     try {\n        JSON.stringify(message);\n      } catch(err) {\n        throw new Error('Cant send type of message, Error: ' + err);\n        message = { error: 'could not run json on event object' };\n      }\n      // Send the message directly\n      window.parent.postMessage(message, self.url);\n    } else {\n      // Add message to queue until device and meteor both are ready\n      self.messageQueue.push(message);\n    }\n  };\n\n  self.connection = function(msg) {\n    if (typeof msg.handshake !== 'undefined') {\n      // We got a handshake from the cordova\n      self.handshakeActivated = true;\n      // Respond to parent do shake back\n      self.send({ handshake: msg.handshake });\n      // Resume queue FIFO\n      if (typeof self.messageQueue !== 'undefined') {\n        for (var i = 0; i < self.messageQueue.length; i++) {\n          self.send(self.messageQueue[i]);\n        }\n      }\n      // Empty queue array\n      self.messageQueue = [];\n    }\n\n    // We got an event to dispatch\n    if (typeof msg.eventId !== 'undefined') {\n      var listeners = self.eventCallbacks[msg.eventId];\n      if (typeof listeners !== 'undefined') {\n        // Trigger all listeners for this event\n        for (var i = 0; i < listeners.length; i++) {\n          try {\n            listeners[i].apply(window, [msg.payload]);\n          } catch(err) {\n          }\n        }\n        // If this is a one time event like deviceready remove all listeners\n        if (self.oneTimeEvents[msg.eventId]) {\n          delete self.eventCallbacks[msg.eventId];\n        }\n      }\n    } // EO msg event\n\n    // We got a callback function invoked\n    if (typeof msg.invokeId !== 'undefined' &&\n            typeof msg.funcId !== 'undefined' &&\n            typeof msg.args !== 'undefined') {\n\n      // Get the invoke object\n      var invoked = self.invokes[msg.invokeId];\n      if (typeof invoked === 'undefined') {\n        return;\n      }\n\n      // Get the invoked function\n      var invokedFunction = invoked[msg.funcId];\n      if (typeof invokedFunction === 'undefined') {\n        return;\n      }\n\n      var functionToRemove = 0;\n      var removeInvoked = false;\n      // scope eg. this.remove() and this.removeAll() these will\n      // remove the current callback or all callbacks of this call\n      var removeScope = {\n        remove: function() {\n          functionToRemove = msg.funcId;\n        },\n        removeAll: function() {\n          removeInvoked = true;\n        }\n      };\n\n      if (typeof invokedFunction !== 'function') {\n        throw new Error('ERROR: Execute client callback '+msg.invokeId+' funcId: '+msg.funcId + ' not a function');\n        return;\n      }\n\n      // Make sure that we have an array to pass on in the apply\n      var args = [];\n      for (var key in msg.args) {\n        args.push(msg.args[key]);\n      }\n\n      // All set, we callback the function\n      try {\n        invokedFunction.apply(removeScope, args);\n      } catch(err) {\n        throw new Error('ERROR: Execute client callback '+msg.invokeId+' funcId: '+msg.funcId + ' Error: ' + err);\n      }\n\n      // If the returning callback then delete this?\n      // Garbage collection?\n      if (msg.funcId === functionToRemove || removeInvoked) {\n\n        if (Object.keys(invoked).length === 1 || removeInvoked) {\n          // The invoked method call only contains returning callback, we\n          // Remove the invoke itself since there will be no more calls\n          delete self.invokes[msg.invokeId];\n        } else {\n          // Even if we delete an item the index is preserved so the callback\n          // funcId still points to the right function\n          delete self.invokes[msg.invokeId][msg.funcId];\n        }\n      }\n    } // EO method\n\n    if (msg.error) {\n      throw new Error('Client got error back ' + msg.error);\n    }\n  }; // EO Connection\n\n  self.messageEventHandler = function(event) {\n    // If message is from meteor then\n    if (event.origin === self.url) {\n      // We have a connection\n      self.connection(event && event.data);\n    }\n  };\n\n  // Start listening for messages\n  if (typeof window.addEventListener !== 'undefined') {\n    window.addEventListener('message', self.messageEventHandler, false);\n  }\n\n  // Listen for deviceready event\n  self.addEventListener('deviceready', function() {\n    // Set the ready flag\n    self.setReady(true);\n    // Activate all native plugin API's\n    for (var key in self.plugins) {\n      if (self.plugins.hasOwnProperty(key)) {\n        self.plugins[key] = true;\n      }\n    }\n  });\n\n  return self;\n};\n","/*\n\nMeteor-Cordova, by RaiX\n\nCredit goes to @awatson1978 and @zeroasterisk\n\nMIT License\n\nThis file extends the cordova with notification plugin api\n\n*/\n\n/*\n\tbeep - does what is says\n\tbeep(duration, type, callback);\n\tcallback when beep is done\n */\n\nif (typeof Cordova === 'undefined') {\n  alert('wrong load order?');\n}\n\nvar beep = (function () {\n\ttry {\n\t\t// Fix up for prefixing\n\t\twindow.AudioContext = window.AudioContext||window.webkitAudioContext;\n\t\tcontext = new AudioContext();\n\t} catch(e) {\n\t\treturn function(duration, type, callback) {\n\t\t\t// Not supported by the browser\n\t\t};\n\t}\n\n    return function (duration, type, callback) {\n        var osc = context.createOscillator();\n\n\t\t// 0 Sine wave\n\t\t// 1 Square wave\n\t\t// 2 Sawtooth wave\n\t\t// 3 Triangle wave\n        osc.type = (type % 4) || 0;\n\n        osc.connect(context.destination);\n        osc.noteOn(0);\n        Meteor.setTimeout(function() {\n          osc.noteOff(0);\n          // Callback when beep stops\n          if (typeof callback === 'function') {\n\t\t\t\t    callback();\n          }\n        }, duration);\n    };\n})();\n\n//////////////// Unified common API //////////////////\n\nCordova.prototype.alert = function(message, alertCallback, title, buttonName) {\n\tvar self = this;\n\tconsole.log(typeof alertCallback);\n\tif (typeof alertCallback !== 'function')\n\t\tthrow new Error('Function \"alert\" expects a callback function');\n\n\tif (self.plugins.notification || self.plugins.dialogs) {\n\t\tself.call('navigator.notification.alert', [message, alertCallback, title, buttonName]);\n  } else {\n\t\t// title, buttonName ?\n\t\twindow.alert(message);\n\t\talertCallback();\n\t}\n};\n\nCordova.prototype.confirm = function(message, confirmCallback, title, buttonLabels) {\n\tvar self = this;\n\tif (typeof confirmCallback !== 'function')\n\t\tthrow new Error('Function \"confirm\" expects a callback function');\n\n\tif (self.plugins.notification || self.plugins.dialogs) {\n\t\tself.call('navigator.notification.confirm', [message, confirmCallback, title, buttonLabels]);\n  } else {\n\t\tconfirmCallback( window.confirm(message)? 1 : 2 );\n  }\n};\n\nCordova.prototype.prompt = function(message, promptCallback, title, buttonLabels, defaultText) {\n\tvar self = this;\n  if (typeof promptCallback !== 'function')\n    throw new Error('Function \"prompt\" expects a callback function');\n\n  if (self.plugins.notification || self.plugins.dialogs) {\n\t\tself.call('navigator.notification.prompt', [message, promptCallback, title, buttonLabels, defaultText]);\n  } else {\n    var result = window.prompt(message, defaultText);\n\t\tpromptCallback({\n      input1: result,\n      buttonIndex: (result === null || result === '')? 2 : 1\n    });\n  }\n\n};\n\nCordova.prototype.beep = function(times) {\n\tvar self = this;\n  times = times || 1;\n\tif (self.plugins.notification || self.plugins.dialogs) {\n\t\tself.call('navigator.notification.beep', [times]);\n  } else {\n\t\tvar beepTimes = function(countDown) {\n\t\t\tbeep(100, 3, function() {\n\t\t\t\tif (countDown > 1)\n\t\t\t\t\tbeepTimes(countDown - 1);\n\t\t\t});\n\t\t};\n\t\tbeepTimes(times);\n\t}\n};\n\nCordova.prototype.vibrate = function(milliseconds) {\n\tvar self = this;\n\tif (self.plugins.notification || self.plugins.vibration) {\n\t\tself.call('navigator.notification.vibrate', [milliseconds]);\n  } else {\n\t\tbeep(milliseconds, 0);\n  }\n};\n\nCordova.prototype.close = function() {\n  var self = this;\n  self.call('navigator.app.exitApp');\n};\n"]}