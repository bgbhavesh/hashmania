{"version":3,"file":"/packages/cordova:tests.js","sources":["cordova/plugin/meteor.cordova.js","cordova/meteor.cordova.tests.js"],"names":[],"mappings":";;;;;;;;AAAA,E;;AAEA,gB;;AAEA,6E;AACA,U;;;AAGA,U;;AAEA,kC;;AAEA,a;AACA,+B;AACA,yC;AACA,4E;AACA,sD;AACA,6D;AACA,gE;AACA,G;;AAEA,qB;AACA,+E;AACA,4C;;AAEA,6E;AACA,mB;;AAEA,E;;;AAGA,oB;AACA,mC;AACA,qE;AACA,I;AACA,C;;AAEA,W;;AAEA,kC;AACA,gF;AACA,iB;AACA,mC;AACA,kB;AACA,K;AACA,mC;AACA,e;AACA,G;AACA,8C;AACA,E;;AAEA,iC;AACA,+E;AACA,sC;AACA,E;;AAEA,kC;AACA,oE;AACA,E;;AAEA,oC;;AAEA,kD;AACA,0B;AACA,mB;;AAEA,kC;AACA,yC;AACA,sC;AACA,iC;AACA,K;AACA,gD;AACA,+B;AACA,2F;AACA,O;AACA,K;AACA,G;;AAEA,0B;AACA,uF;AACA,G;;AAEA,U;AACA,8B;AACA,a;AACA,G;AACA,mB;AACA,4C;AACA,G;AACA,0B;AACA,iC;AACA,G;AACA,0B;AACA,oC;AACA,wC;AACA,oB;AACA,K;AACA,e;AACA,G;AACA,mD;AACA,+C;;AAEA,yB;AACA,a;AACA,uC;AACA,qB;AACA,kD;AACA,0C;AACA,uB;AACA,O;AACA,K;;AAEA,yB;AACA,iB;AACA,Y;AACA,iC;AACA,K;AACA,G;AACA,0E;AACA,sC;AACA,qB;AACA,G;AACA,yB;AACA,W;AACA,sB;AACA,gC;AACA,uB;AACA,kD;AACA,0C;AACA,yB;AACA,O;AACA,K;AACA,G;;AAEA,oC;AACA,e;AACA,U;AACA,+B;AACA,G;AACA,E;;AAEA,6C;AACA,a;AACA,kB;AACA,qC;AACA,uB;;AAEA,gC;;AAEA,kC;;AAEA,0E;;AAEA,gB;AACA,2B;AACA,sE;;AAEA,oB;AACA,iC;AACA,iC;AACA,U;AACA,+B;AACA,yD;;AAEA,mD;;AAEA,sB;AACA,uC;AACA,4C;AACA,6B;AACA,Q;AACA,Y;AACA,iE;AACA,K;AACA,G;;AAEA,gF;;AAEA,iC;AACA,8E;AACA,W;AACA,gC;AACA,oB;AACA,oE;AACA,O;AACA,+D;AACA,K;AACA,I;;AAEA,mC;AACA,qB;AACA,iE;AACA,K;AACA,8E;AACA,mF;AACA,I;;AAEA,kD;AACA,qB;AACA,iD;AACA,K;AACA,4C;AACA,iB;AACA,yB;AACA,wB;AACA,S;AACA,Y;AACA,4D;AACA,sC;AACA,O;AACA,qC;AACA,yB;AACA,wB;AACA,S;AACA,K;AACA,I;;AAEA,wD;AACA,qB;AACA,wE;AACA,K;AACA,e;AACA,yB;AACA,qB;AACA,gB;AACA,O;AACA,I;;AAEA,6C;AACA,6D;AACA,0D;AACA,iE;AACA,+C;AACA,O;AACA,iB;AACA,sC;AACA,K;;AAEA,uE;AACA,6C;AACA,sE;AACA,wF;AACA,2C;AACA,6D;;AAEA,sB;AACA,yB;AACA,8B;AACA,K;;AAEA,6B;AACA,yD;AACA,wD;AACA,4C;AACA,yD;AACA,6C;AACA,gD;AACA,gB;AACA,K;AACA,I;;;AAGA,gF;AACA,0C;AACA,mC;AACA,0C;AACA,c;;AAEA,sD;AACA,+C;AACA,yB;AACA,uF;AACA,S;;AAEA,2C;AACA,O;;AAEA,sF;AACA,yB;AACA,oE;AACA,S;AACA,uC;AACA,O;;AAEA,gD;AACA,gD;AACA,mD;AACA,gD;;AAEA,yB;AACA,mF;AACA,S;AACA,yD;AACA,0C;AACA,sC;AACA,2E;AACA,iC;;AAEA,4D;AACA,6C;AACA,uE;AACA,mE;AACA,qD;AACA,4D;AACA,mD;AACA,iD;AACA,iD;AACA,oB;AACA,gE;AACA,6D;AACA,a;AACA,W;;AAEA,gD;AACA,iD;;AAEA,2D;AACA,yC;;AAEA,4C;AACA,+C;AACA,uE;AACA,sC;AACA,8B;AACA,8B;AACA,+C;AACA,oD;AACA,2D;AACA,6C;AACA,wC;AACA,gF;AACA,yD;AACA,2C;AACA,mB;AACA,iF;AACA,iC;AACA,0D;AACA,wC;AACA,gC;AACA,kE;AACA,mD;AACA,sE;AACA,0D;AACA,iE;AACA,wC;AACA,sE;AACA,oD;AACA,2B;;AAEA,oE;AACA,0B;AACA,oD;AACA,kD;AACA,sB;AACA,mB;AACA,iB;AACA,e;;AAEA,4E;AACA,uD;AACA,iC;;AAEA,8E;AACA,oD;AACA,yD;AACA,+B;;AAEA,gB;AACA,4D;AACA,S;AACA,+C;AACA,yB;AACA,I;;AAEA,8C;AACA,qC;AACA,oC;AACA,6B;AACA,2C;AACA,Y;AACA,0F;AACA,K;AACA,I;;AAEA,iC;AACA,uD;AACA,wE;AACA,G;;AAEA,c;AACA,E;;;;;;;;;;;;;;;;;;;ACtYA,a;;AAEA,uB;AACA,qD;AACA,C;;AAEA,wB;;AAEA,sC;AACA,a;AACA,wB;AACA,U;AACA,wB;AACA,G;AACA,E;;AAEA,wD;AACA,uC;AACA,mB;AACA,G;;AAEA,8B;AACA,E;;AAEA,iB;AACA,kC;AACA,sD;AACA,I;AACA,qC;AACA,+C;AACA,wB;AACA,+B;AACA,Q;AACA,I;AACA,a;AACA,qB;AACA,G;AACA,E;;AAEA,iB;AACA,qB;AACA,kB;AACA,oC;AACA,6D;AACA,K;AACA,I;AACA,iD;AACA,oB;AACA,yC;AACA,kF;AACA,K;AACA,0C;AACA,8D;AACA,wC;AACA,K;AACA,wB;AACA,gD;AACA,I;AACA,4C;AACA,oB;AACA,uC;AACA,qE;AACA,a;AACA,yD;AACA,4C;AACA,qB;AACA,S;AACA,O;AACA,K;AACA,I;AACA,qC;AACA,iD;AACA,sC;AACA,+B;AACA,Q;AACA,I;AACA,uB;AACA,E;;;;;;;AAOA,0D;AACA,uB;AACA,mB;AACA,4B;AACA,kB;AACA,e;AACA,sB;AACA,G;;AAEA,6B;AACA,0B;AACA,c;AACA,G;;AAEA,2D;AACA,gG;AACA,G;;AAEA,E;AACA,8E;AACA,mB;AACA,kC;AACA,uE;AACA,qE;;AAEA,mB;AACA,O;;AAEA,G;;AAEA,S;AACA,G;;AAEA,+D;AACA,sC;AACA,uF;AACA,qF;AACA,G;;AAEA,uD;AACA,mB;AACA,e;AACA,I;;AAEA,kB;AACA,6B;;AAEA,8G;AACA,iD;;AAEA,0B;AACA,mD;AACA,c;AACA,4C;AACA,K;;AAEA,0G;;;AAGA,uC;AACA,4C;AACA,4C;AACA,gE;;;AAGA,oI;AACA,kJ;AACA,mD;;AAEA,0D;AACA,yB;AACA,4C;AACA,K;;;AAGA,uB;AACA,mD;AACA,mD;;AAEA,+E;AACA,G;;AAEA,kF;AACA,mB;AACA,uD;AACA,4B;AACA,iB;AACA,K;;AAEA,0E;AACA,G;;AAEA,0E;AACA,mB;AACA,iB;AACA,O;AACA,oC;AACA,gB;AACA,a;AACA,G;;AAEA,kF;AACA,G;;AAEA,0F;AACA,mB;AACA,mD;AACA,4B;AACA,iB;AACA,K;AACA,G;;AAEA,gF;AACA,mB;AACA,0D;AACA,oC;AACA,iB;AACA,K;AACA,G;;AAEA,wF;AACA,mB;AACA,sD;AACA,oC;AACA,iB;AACA,K;AACA,G;;AAEA,oG;AACA,mB;AACA,sC;AACA,iB;AACA,I;;AAEA,sB;AACA,uC;AACA,G;;AAEA,2F;AACA,mB;AACA,iE;AACA,kC;AACA,iB;AACA,K;AACA,G;;;;AAIA,oG;AACA,kB;;AAEA,uB;AACA,c;AACA,wB;AACA,mB;AACA,K;AACA,G;;AAEA,mB;AACA,wE;AACA,sC;AACA,+B;AACA,e;AACA,uB;AACA,kC;AACA,4C;AACA,e;AACA,K;;AAEA,G;;AAEA,sC;AACA,iH;;AAEA,mB;AACA,wE;AACA,sC;AACA,+B;AACA,iB;AACA,M;;AAEA,G;;;AAGA,0F;AACA,kB;AACA,kB;AACA,kB;AACA,uB;;AAEA,gE;AACA,Y;AACA,+B;AACA,Y;AACA,Y;AACA,gC;AACA,I;;;AAGA,wB;AACA,kB;AACA,c;AACA,G;;AAEA,wB;AACA,c;AACA,qB;AACA,G;;AAEA,wB;AACA,iD;AACA,c;AACA,G;;AAEA,mB;AACA,2F;AACA,kC;AACA,4C;AACA,mB;AACA,K;;AAEA,gC;AACA,sD;AACA,sD;AACA,qD;AACA,+D;AACA,iB;AACA,U;AACA,G;;AAEA,sC;AACA,wG;;AAEA,sB;AACA,qB;AACA,qB;;AAEA,kD;AACA,kB;AACA,sC;AACA,mB;AACA,I;;AAEA,0C;AACA,0E;AACA,iB;AACA,I;;AAEA,mB;AACA,0E;AACA,sC;AACA,+B;AACA,iB;AACA,K;;AAEA,gC;AACA,oE;AACA,kE;AACA,kE;AACA,iB;AACA,U;;AAEA,G;;;AAGA,sD;AACA,wB;AACA,6C;;AAEA,iB;;AAEA,W;AACA,gB;AACA,W;AACA,a;AACA,e;AACA,gB;AACA,U;AACA,c;AACA,U;AACA,iB;AACA,O;AACA,M;AACA,mD;AACA,e;AACA,c;AACA,qB;AACA,U;AACA,S;AACA,I;;AAEA,oB;;AAEA,iB;;AAEA,W;AACA,gB;AACA,W;AACA,a;AACA,e;AACA,gB;AACA,U;AACA,c;AACA,U;AACA,iB;AACA,O;AACA,M;AACA,yC;AACA,mC;AACA,c;AACA,qB;AACA,2C;AACA,0C;AACA,I;;AAEA,+B;;AAEA,2F;AACA,K;AACA,W;AACA,sB;AACA,qB;AACA,0C;AACA,uB;AACA,oB;AACA,oB;AACA,0B;AACA,gB;AACA,a;AACA,mB;AACA,6B;AACA,0C;AACA,c;AACA,2B;AACA,oB;AACA,c;AACA,gB;AACA,uB","sourcesContent":["/*\n\nMeteor - Cordova\n\nIt's a small interface for external meteor to communicate with native cordova\nand events\n\n\narguments:\n\n  meteorUrl - url to remote meteor\n\n  options = {\n    version - app shell version\n    appcache - should we rely on appcache\n    onload(e, callbackUrlFlag) - callback for when the iframe is loaded with\n    meteor or fallbackUrl (if callbackUrlFlag == true)\n    fallbackUrl - if load check fails then this url is called\n    debug - true or false - true then write to console on errors\n  }\n\n  .load([ callback ])\n  callback(error) - is called at load test time - if appcache is relyed on then\n                    this is call immediately\n\n  .onError can be overwritten if wanting custom functionality - default is to\n  fallback on error\n\n*/\n\n\nif(!Array.isArray) {\n  Array.isArray = function (vArg) {\n    return Object.prototype.toString.call(vArg) === '[object Array]';\n  };\n}\n\nEJSON = {};\n\nEJSON.newBinary = function (len) {\n  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\n    var ret = [];\n    for (var i = 0; i < len; i++) {\n      ret.push(0);\n    }\n    ret.$Uint8ArrayPolyfill = true;\n    return ret;\n  }\n  return new Uint8Array(new ArrayBuffer(len));\n};\n\nEJSON.isBinary = function (obj) {\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill));\n};\n\nEJSON.isGlobal = function (vArg) {\n  return Object.prototype.toString.call(vArg) === '[object global]';\n};\n\nEJSON.emptyFunction = function() {};\n\nEJSON.clone = function (v /* list of parents */) {\n  // How deep should we go\n  var maxLevel = 2;\n\n  // Check for circular references\n  if (typeof arguments !== 'undefined') {\n    if (arguments.length > maxLevel) {\n      return EJSON.emptyFunction;\n    }\n    for (var i = 1; i < arguments.length; i++) {\n      if (v === arguments[i]) {\n        return EJSON.emptyFunction; //function() {}; // If JSON.stringify it'll be left out\n      }\n    }\n  }\n\n  if (EJSON.isGlobal(v)) {\n    return EJSON.emptyFunction; //function() {}; // If JSON.stringify it'll be left out\n  }\n\n  var ret;\n  if (typeof v !== 'object') {\n    return v;\n  }\n  if (v === null) {\n    return null; // null has typeof \"object\"\n  }\n  if (v instanceof Date) {\n    return new Date(v.getTime());\n  }\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift(1); // We add prefix an argument\n\n  if (Array.isArray(v)) {\n    ret = [];\n    for (var i = 0; i < v.length; i++){\n      args[0] = v[i];\n      var value = EJSON.clone.apply(window, args);\n      if (value !== EJSON.emptyFunction) {\n        ret[i] = value;\n      }\n    }\n\n    if (ret.length > 0) {\n      return ret;\n    } else {\n      return EJSON.emptyFunction;\n    }\n  }\n  // handle general user-defined typed Objects if they have a clone method\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  }\n  // handle other objects\n  ret = {};\n  for (var key in v) {\n    if (v.hasOwnProperty(key)) {\n      args[0] = v[key];\n      var value = EJSON.clone.apply(window, args);\n      if (value !== EJSON.emptyFunction) {\n        ret[key] = value;\n      }\n    }\n  }\n\n  if (Object.keys(ret).length > 0) {\n    return ret;\n  } else {\n    return EJSON.emptyFunction;\n  }\n};\n\nMeteorCordova = function(iframeId, options) {\n  // Rig vars\n  var self = this;\n  // Send queue until client is ready\n  self.eventQueue = {};\n\n  self.activeEventListener = {};\n\n  self.handshakeActivated = false;\n\n  self.testFrame = (options && options.testFrame)?options.testFrame:false;\n\n  // Rig Options\n  self.iframeId = iframeId;\n  self.debug = !!(options && options.debug && options.debug === true);\n\n  // Testing purpose\n  if (self.testFrame !== false) {\n    self.iframe = self.testFrame;\n  } else {\n    // Try to fetch the element\n    self.iframe = document.getElementById(self.iframeId);\n\n    self.url = self.iframe.src.replace(/\\/+$/, '');\n\n    if (self.iframe) {\n      self.iframe.onload = function() {\n        self.iframe.style.display = 'block';\n        self.sendHandshake();\n      };\n    } else {\n      throw new Error('Could not find iFrame: ' + self.iframeId);\n    }\n  }\n\n  // We registrer the onload event - otherwise we just fail, can we catch error?\n\n  self.send = function(message) {\n    if (self.iframe && self.iframe.contentWindow && self.handshakeActivated) {\n      try {\n        JSON.stringify(message);\n      } catch(err) {\n        message = { error: 'could not run json on message object' };\n      }\n      self.iframe.contentWindow.postMessage(message, self.url);\n    }\n  };\n\n  self.sendHandshake = function() {\n    if (self.debug) {\n      console.log('------------ SEND HANDSHAKE!!! ------------');\n    }\n    // Send a handshake to the client to make sure we are all on the same page\n    self.iframe.contentWindow.postMessage({ handshake: 'Meteor Rocks!'}, self.url);\n  };\n\n  self.triggerEvent = function(eventId, payload) {\n    if (self.debug) {\n      console.log('Event triggered: ' + eventId);\n    }\n    if (self.activeEventListener[eventId]) {\n      self.send({\n        eventId: eventId,\n        payload: payload\n      });\n    } else {\n      if (typeof self.eventQueue[eventId] === 'undefined') {\n        self.eventQueue[eventId] = [];\n      }\n      self.eventQueue[eventId].push({\n        eventId: eventId,\n        payload: payload\n      });\n    }\n  };\n\n  self.sendCallback = function(invokeId, funcId, args) {\n    if (self.debug) {\n      console.log('----Send callback ' + invokeId + ' func: ' + funcId);\n    }\n    self.send({\n      invokeId: invokeId,\n      funcId: funcId,\n      args: args\n    });\n  };\n\n  self.addEventListener = function(eventId) {\n    // Check if any events have been waiting for subscription\n    if (typeof self.eventQueue[eventId] !== 'undefined') {\n      for (var i = 0; i < self.eventQueue[eventId].length; i++) {\n        self.send(self.eventQueue[eventId][i]);\n      }\n      // Clean up\n      delete self.eventQueue[eventId];\n    }\n\n    // Set a flag so we dont have multiple event messages over the line\n    self.activeEventListener[eventId] = true;\n    // Well, some events are based on window - so we have to know this\n    var windowEvents = { batterycritical: true, batterylow: true, batterystatus: true };\n    // Get the event taget for this eventId\n    var target = (windowEvents[eventId]) ? window : document;\n\n    // Testing purpose\n    if (self.testFrame) {\n      target = self.testFrame;\n    }\n\n    // Add the event listener\n    if (typeof target.addEventListener !== 'undefined') {\n      target.addEventListener(eventId, function(event) {\n        // Got an event, let et be triggered\n        // make a json proper object out off the event...\n        var clonedEvent = EJSON.clone(event);\n        self.triggerEvent(eventId, clonedEvent);\n      }, false);\n    }\n  };\n\n\n  // TODO: test this function - maybe isolate the get function / value part into\n  // a seperate function for test abillity\n  self.connection = function(msg) {\n    // We rig a connection for the iframe.\n    if (msg) {\n\n      //  EVENT - If meteor wants to listen for events\n      if (typeof msg.eventId !== 'undefined') {\n        if (self.debug) {\n          console.log('------------ REGISTRER EVENT ' + msg.eventId + ' ------------');\n        }\n\n        self.addEventListener(msg.eventId);\n      }\n\n      if (typeof msg.handshake !== 'undefined' && msg.handshake === 'Meteor Rocks!') {\n        if (self.debug) {\n          console.log('------------ GOT HANDSHAKE!!! ------------');\n        }\n        self.handshakeActivated = true;\n      }\n\n      // CALL - if an function call then execute\n      if (typeof msg.invokeId !== 'undefined' &&\n              typeof msg.command !== 'undefined' &&\n              typeof msg.args !== 'undefined') {\n\n        if (self.debug) {\n          console.log('------------ CALL METHOD ' + msg.command + ' ------------');\n        }\n        // Guess we got something like window.console.log\n        var keys = msg.command.split('.');\n        if (keys && keys.length > 0) {\n          // Set reference to root element, window contains window - global\n          var reference = window;\n\n          // We save the last element for execution or fetch\n          var last = keys[ keys.length - 1 ];\n          // Iterate over command elements first ref: window[ keys[i] ]\n          // We stop a level before hitting the last item: [0 .. n[\n          for (var a = 0; a < keys.length - 1; a++) {\n            // Check that the reference scope isnt undefined\n            if (typeof reference !== 'undefined') {\n              // set new reference a level deeper\n              reference = reference[ keys[ a ] ];\n            } else {\n              // If reference is undefined then somethings wrong\n              throw new Error('Can not call ' + msg.command);\n            }\n          }\n\n          // We now have the second last element\n          if (typeof reference !== 'undefined') {\n\n            // Set the result to the last reference element\n            var result = reference[last];\n\n            // Check if result is a function\n            if (typeof result === 'function') {\n              // We got a reference to a function so we have to prepare\n              // arguments in an array\n              var myArgs = [];\n              var counter = 0;\n              // We iterate over msg.args array\n              if (typeof msg.args !== 'undefined') {\n                for (var i = 0; i < msg.args.length; i++) {\n                  // Get the current argument\n                  var arg = msg.args[i];\n                  // If argument is a value then push the value to new arguments\n                  if (typeof arg.value !== 'undefined') {\n                    myArgs.push(arg.value);\n                  }\n                  // If argument is a function then push a callback with invokeId\n                  // as reference\n                  if (typeof arg.funcId !== 'undefined') {\n                    // push new argument\n                    myArgs.push(\n                      // Bind values could use _.bind for this too\n                      (function(invokeId, funcId) {\n                        // Return the actual function for the argument\n                        return function(/* arguments */) {\n                          // Convert to an array to be consistent\n                          var args = [];\n                          for (var i = 0; i < arguments.length; i++) {\n                            args.push(arguments[i]);\n                          }\n\n                          self.sendCallback(invokeId, funcId, args);\n                        };\n                      // Run with the values to bind\n                      })(msg.invokeId, arg.funcId)\n                    );\n                  }\n                }\n              }\n\n              // We call the referenced function, result was typeof function\n              result = result.apply(reference, myArgs);\n            } // EO is a function\n\n            // We send the result of the var or function back to the resulting\n            // Callback, this allways has funcId = 0\n            self.sendCallback(msg.invokeId, 0, [result]);\n          } // EO Got reference\n\n        } else {\n          throw new Error('ERROR: command is out of scope');\n        }\n      } // Execute a function or get a variable\n    } // EO Got a message\n  };\n\n  self.messageEventHandler = function(event) {\n    // If message is from meteor then\n    if (event.origin === self.url) {\n      // We have a connection\n      self.connection(event && event.data);\n    } else {\n      throw new Error('Origins should match: ' + event.origin + ' === ' + self.url);      \n    }\n  };\n\n  // Start listening for messages\n  if (typeof window.addEventListener !== 'undefined') {\n    window.addEventListener('message', self.messageEventHandler, false);\n  }\n\n  return self;\n};\n","'use strict';\n\nfunction equals(a, b) {\n  return !!(JSON.stringify(a) === JSON.stringify(b));\n}\n\nwindow.testValue = 'ok';\n\nwindow.testFunction = function(name) {\n  if (name) {\n    return 'ok ' + name;\n  } else {\n    return 'ok default';\n  }\n};\n\nwindow.testFunctionCallback = function(name, callback) {\n  if (typeof callback === 'function') {\n    callback(name);\n  }\n\n  return 'returning callback';\n};\n\nwindow.parent = {\n  postMessage: function(message) {\n    testFrame.triggerMessage(JSON.stringify(message));\n  },\n  triggerMessage: function(message) {\n    client.messageEventHandler.apply(client, [{\n      origin: 'file://',\n      data: JSON.parse(message)\n    }]);\n  },\n  location: {\n    origin: 'file://'\n  }\n};\n\nvar testFrame = {\n  eventCallbacks: {},\n  contentWindow: {\n    postMessage: function(message) {\n      window.parent.triggerMessage(JSON.stringify(message) );\n    }\n  },\n  addEventListener: function(eventId, callback) {\n    var self = this;\n    if (typeof callback !== 'function') {\n      throw new Error('testFrame.addEventListener expected callback as function');\n    }\n    // Check if we need the init the array\n    if (typeof self.eventCallbacks[eventId] === 'undefined') {\n      self.eventCallbacks[eventId] = [];\n    }\n    // Push to the array\n    self.eventCallbacks[eventId].push(callback);\n  },\n  triggerEvent: function(eventId, payload) {\n    var self = this;\n    if (self.eventCallbacks[eventId]) {\n      for (var i = 0; i < self.eventCallbacks[eventId].length; i++) {\n        try {\n          var callback = self.eventCallbacks[eventId][i];\n          callback.apply(window, [payload]);\n        }catch(err) {\n        }\n      }\n    }\n  },\n  triggerMessage: function(message) {\n    cordova.messageEventHandler.apply(cordova, [{\n      origin: 'http://localhost:3000',\n      data: JSON.parse(message)\n    }]);\n  },\n  onload: function() {}\n};\n\n\n\n\n\n\nvar cordova = new MeteorCordova('http://localhost:3000', {\n  // This shell version\n  version: '0.0.1',\n  // Do we rely on appcache?\n  appcache: false,\n  debug: false,\n  testFrame: testFrame\n});\n\n// Initialise the client last\nvar client = new Cordova({\n  debug: false\n});\n\nTinytest.add('MeteorCordova - test suite', function(test) {\n  test.isTrue(typeof cordova.testFrame !== false, 'cordova is rigged for iframe no testFrame?');\n});\n\n/*\nTinytest.addAsync('MeteorCordova - load test, ', function (test, onComplete) {\n  function load() {\n    cordova.load(function(error) {\n      // This should not return an error since we are running localhost\n      test.isUndefined(error, 'This test excpects to run localhost');\n\n      onComplete();\n    });\n\n  }\n\n  load();\n});\n\nTinytest.add('MeteorCordova - test handshake', function(test) {\n  testFrame.onload({ event: 'test' });\n  test.isTrue(cordova.handshakeActivated, 'The cordova handshake should be activated');\n  test.isTrue(client.handshakeActivated, 'The client handshake should be activated');\n});\n\nTinytest.add('MeteorCordova - Events', function(test) {\n  var eventData = {\n    data: 'Hej'\n  };\n\n  var counter = 0;\n  var counterDeviceReady = 0;\n\n  test.isUndefined(client.eventCallbacks['test'], 'Before we start the event callbacks list should be empty');\n  test.isUndefined(client.oneTimeEvents['test']);\n\n  // Add an event listener\n  client.addEventListener('test', function(event) {\n    counter++;\n    test.isTrue( equals(event, eventData) );\n  });\n\n  test.isTrue(typeof client.eventCallbacks['test'][0] === 'function', 'We would expect the handler as 0');\n\n\n  // Now we trigger the event with data\n  testFrame.triggerEvent('test', eventData);\n  testFrame.triggerEvent('test', eventData);\n  test.equal(counter, 2, 'Normal events should run every time');\n\n\n  test.isTrue(client.eventCallbacks['deviceready'] !== 'undefined', 'Before we start the event callbacks deviceready should exist');\n  test.isTrue(client.eventCallbacks['deviceready'].length === 1, 'Before we start the event callbacks deviceready should have one initial event');\n  test.isTrue(client.oneTimeEvents['deviceready']);\n\n  client.addEventListener('deviceready', function(event) {\n    counterDeviceReady++;\n    test.isTrue( equals(event, eventData) );\n  });\n\n\n  // Test oneTime event\n  testFrame.triggerEvent('deviceready', eventData);\n  testFrame.triggerEvent('deviceready', eventData);\n\n  test.equal(counterDeviceReady, 1, 'one time events should only be run once');\n});\n\nTinytest.addAsync('MeteorCordova - call - variable', function (test, onComplete) {\n  // Test variables\n  client.call('window.testValue', [], function(value) {\n    test.equal(value, 'ok');\n    onComplete();\n  });\n\n  client.call('console.log', ['------ TEST CALL CONSOLE LOG ----------']);\n});\n\nTinytest.add('MeteorCordova - call - function not found', function(test) {\n  // Test variables\n  var errors = 0;\n  try {\n    client.call('im.not.found.foo');\n  } catch(err) {\n    errors++;\n  }\n\n  test.equal(errors, 1, 'Call should throw an error the function does not exist');\n});\n\nTinytest.addAsync('MeteorCordova - call - variable no args', function (test, onComplete) {\n  // Test variables\n  client.call('window.testValue', function(value) {\n    test.equal(value, 'ok');\n    onComplete();\n  });\n});\n\nTinytest.addAsync('MeteorCordova - call - method', function (test, onComplete) {\n  // Test variables\n  client.call('window.testFunction', [], function(value) {\n    test.equal(value, 'ok default');\n    onComplete();\n  });\n});\n\nTinytest.addAsync('MeteorCordova - call - method no args', function (test, onComplete) {\n  // Test variables\n  client.call('window.testFunction', function(value) {\n    test.equal(value, 'ok default');\n    onComplete();\n  });\n});\n\nTinytest.addAsync('MeteorCordova - call - method no args no callback', function (test, onComplete) {\n  // Test variables\n  window.testNoCallback = function() {\n    onComplete();\n  };\n\n  // Call the function\n  client.call('window.testNoCallback');\n});\n\nTinytest.addAsync('MeteorCordova - call - method with param', function (test, onComplete) {\n  // Test variables\n  client.call('window.testFunction', ['hello'], function(value) {\n    test.equal(value, 'ok hello');\n    onComplete();\n  });\n});\n\n\n\nTinytest.addAsync('MeteorCordova - call - method with callback param', function (test, onComplete) {\n  var counter = 0;\n\n  function complete() {\n    counter++;\n    if (counter === 2) {\n      onComplete();\n    }\n  }\n\n  // Test variables\n  client.call('window.testFunctionCallback', ['hello', function(value) {\n    // this is a function as parametre\n    test.equal(value, 'hello');\n    complete();\n  }], function(value) {\n    // Test the returning callback\n    test.equal(value, 'returning callback');\n    complete();\n  });\n\n});\n\n// Test for no returning callbacks....\nTinytest.addAsync('MeteorCordova - call - method with callback param no returning', function (test, onComplete) {\n\n  // Test variables\n  client.call('window.testFunctionCallback', ['hello', function(value) {\n    // this is a function as parametre\n    test.equal(value, 'hello');\n    onComplete();\n  }]);\n\n});\n\n\nTinytest.addAsync('MeteorCordova - call - test this.remove', function (test, onComplete) {\n  var aCalled = 0;\n  var bCalled = 0;\n  var cCalled = 0;\n  var returnCalled = 0;\n\n  window.testFunctionCallback5 = function(callA, callB, callC) {\n    callA();\n    callA(); // this should run\n    callB();\n    callC();\n    return 'returning callback';\n  };\n\n\n  function functionA() {\n    this.remove();\n    aCalled++;\n  }\n\n  function functionB() {\n    bCalled++;\n    this.removeAll();\n  }\n\n  function functionC() {\n    test.fail('This function should never run?');\n    cCalled++;\n  }\n\n  // Test variables\n  client.call('testFunctionCallback5', [functionA, functionB, functionC], function(value) {\n    // Test the returning callback\n    test.equal(value, 'returning callback');\n    returnCalled++;\n  });\n\n  Meteor.setTimeout(function() {\n    test.equal(aCalled, 1, 'A should be called once');\n    test.equal(bCalled, 1, 'B should be called once');\n    test.equal(cCalled, 0, 'C should not be called');\n    test.equal(returnCalled, 0, 'Return should not be called');\n    onComplete();\n  }, 100);\n});\n\n// Test for no returning callbacks....\nTinytest.addAsync('MeteorCordova - call - method with callback arguments', function (test, onComplete) {\n\n  var funcCordova = 0;\n  var funcClient = 0;\n  var funcReturn = 0;\n\n  window.testFunctionCallback6 = function(callA) {\n    funcCordova++;\n    callA({message: 'you got mail' });\n    return 'hello';\n  };\n\n  var clientCallback = function(message) {\n    test.equal('you got mail', message.message, 'Message is not correct');\n    funcClient++;\n  };\n\n  // Test variables\n  client.call('testFunctionCallback6', [clientCallback], function(value) {\n    // this is a function as parametre\n    test.equal(value, 'hello');\n    funcReturn++;\n  });\n\n  Meteor.setTimeout(function() {\n    test.equal(funcCordova, 1, 'funcCordova should be called once');\n    test.equal(funcClient, 1, 'funcClient should be called once');\n    test.equal(funcReturn, 1, 'funcReturn should be called once');\n    onComplete();\n  }, 100);\n\n});\n\n\nTinytest.add('MeteorCordova - clone', function(test) {\n  var date = new Date();\n  var c = { d: 'test', q: { test: 'test' } };\n\n  c.circular = c;\n\n  var a = {\n    bool: false,\n    nr: 10,\n    neg: -10,\n    real: 0.32,\n    str: 'text',\n    obj: {\n      c: 'ok',\n      d: {\n        e: 'okay'\n      }\n    },\n    func: function() { return 'function called'; },\n    date: date,\n    nul: null,\n    undef: undefined,\n    c1: c,\n    c2: c\n  };\n\n  a.global = window;\n\n  a.circular = a;\n\n  var b = {\n    bool: false,\n    nr: 10,\n    neg: -10,\n    real: 0.32,\n    str: 'text',\n    obj: {\n      c: 'ok',\n      d: {\n        e: 'okay'\n      }\n    },\n    //func: 'function called', // Removed\n    date: new Date(date.getTime()),\n    nul: null,\n    undef: undefined,\n    c1: { d: 'test', q: { test: 'test' } },\n    c2: { d: 'test', q: { test: 'test' } }\n  };\n\n  var aCloned = EJSON.clone(a);\n\n  test.equal(JSON.stringify(aCloned), JSON.stringify(b), 'clone didnt return as expected');\n});*/\n//Test API:\n//test.isFalse(v, msg)\n//test.isTrue(v, msg)\n//test.equalactual, expected, message, not\n//test.length(obj, len)\n//test.include(s, v)\n//test.isNaN(v, msg)\n//test.isUndefined(v, msg)\n//test.isNotNull\n//test.isNull\n//test.throws(func)\n//test.instanceOf(obj, klass)\n//test.notEqual(actual, expected, message)\n//test.runId()\n//test.exception(exception)\n//test.expect_fail()\n//test.ok(doc)\n//test.fail(doc)\n//test.equal(a, b, msg)\n"]}